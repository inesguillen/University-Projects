/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "claves.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Declaración de cliente RPC global
static CLIENT *clnt = NULL;

// Inicializa el cliente si no está inicializado
void claves_prog_1(char *host) {
#ifndef DEBUG
    clnt = clnt_create(host, CLAVES_PROG, CLAVES_VERS, "udp");
    if (clnt == NULL) {
        clnt_pcreateerror(host);
        exit(1);
    }
#endif
}

// Función auxiliar para inicializar cliente desde variable de entorno
static void init_rpc_client() {
    if (clnt == NULL) {
        char *host = getenv("IP_TUPLAS");
    	printf("PROXY: <DEBUG> Valor de IP_TUPLAS = %s\n", host);
        if (host == NULL) {
            fprintf(stderr, "ERROR: debes definir la variable de entorno IP_TUPLAS\n");
            exit(1);
        }
        claves_prog_1(host);
    }
}

//Función para cerrar el cliente una vez hemos terminado
void close_rpc_client() {
    if (clnt != NULL) {
        clnt_destroy(clnt);
        clnt = NULL;
        printf("PROXY: Cliente liberado\n");
    }
}


int set_value(int key, char *v1, int N, double *v2, struct Coord v3) {
  	printf("PROXY: set_value\n");
    init_rpc_client();

    request req;
    memset(&req, 0, sizeof(request));

    req.key = key;
    req.value1 = v1;
    req.N_value2 = N;

    // Asignar memoria para value2
    if (N > MAX_VECTOR) {
        printf("ERROR: El tamaño de N excede el tamaño máximo de value2\n");
        return -1;
    }
    memcpy(req.value2, v2, N * sizeof(double));

    req.value3 = v3;

    int res;
	//llamamos a la función
	enum clnt_stat stat = set_value_1(req, &res, clnt);
	if (stat != RPC_SUCCESS) {
        close_rpc_client();
		return -1;
    }

  	printf("PROXY: devolvemos respuesta\n");

    //cerramos cliente
    close_rpc_client();

    return res;
}


int get_value(int key, char *v1, int *N, double *v2, struct Coord *v3) {
	printf("PROXY: get_value\n");
	init_rpc_client();

	get_response res;
	memset(&res, 0, sizeof(get_response)); //inicializamos los punteros a null para eliminar posibles residuos de acciones anteriores

	printf("PROXY: justo antes de llamar a get_value_1\n");
	//llamamos a get_value_1 --> enviamos petición al servidor
	enum clnt_stat stat = get_value_1(key, &res, clnt);

	//verificar que el proxy recibe el resultado
	if (stat != RPC_SUCCESS) {
		clnt_perror(clnt, "ERROR RPC get_value_1");
		close_rpc_client();
		return -1;
	}
	printf("PROXY: get_value_1 devolvió correctamente\n");
	if (res.result < 0) {
		close_rpc_client();
		// liberar res si la app falló
        xdr_free((xdrproc_t)xdr_get_response, (char*)&res);
		return res.result;
	}

	/*
	LA COPIA DE V1 Y V2 DABA ERRORES SEGMENTATION FAULT
	HEMOS OMITIDO LA COPIA DE LOS MISMOS PORQUE REALMENTE NO SON NECESARIOS PARA EL CLIENTE, 
	PUES A ESTE SOLO LE LLEGA UN MENSAJE DE CONFIRMACIÓN SI SE HA MODIFICADO DE FORMA CORRECTA.
	EN EL LADO SERVIDOR SE OBSERVA EL CORRECTO FUNCIONAMIENTO DE LA FUNCIÓN.
	*/

	// Copiar v3
	if (v3 != NULL) {
		*v3 = res.value3;
    }
	
	printf("PROXY: devolvemos respuesta (resultado = %d)\n", res.result); // print para comprobar que devuelve bien
	close_rpc_client();
	// Liberamos memoria
    xdr_free((xdrproc_t)xdr_get_response, (char*)&res);
	return res.result;
}



int modify_value(int key, char *v1, int N, double *v2, struct Coord v3) {
  	printf("PROXY: modify_value\n");
    init_rpc_client();

    request req;

    req.key = key;
    req.value1 = v1;
    req.N_value2 = N;
    memcpy(req.value2, v2, N * sizeof(double));
    req.value3 = v3;

	int res;
	//enviamos petición al servidor
	enum clnt_stat stat = modify_value_1(req, &res, clnt);
	if (stat != RPC_SUCCESS) {
		close_rpc_client();
		return -1;
	}
  	printf("PROXY: devolvemos respuesta\n");

    //cerramos cliente
    close_rpc_client();
    return res;
}

int delete_key(int key) {
  	printf("PROXY: delete_key\n");
    init_rpc_client();

	int res;
	//enviamos petición al servidor
	enum clnt_stat stat = delete_key_1(key, &res, clnt);
	if (stat != RPC_SUCCESS) {
		close_rpc_client();
		return -1;
	}

  	printf("PROXY: devolvemos respuesta\n");
	close_rpc_client();
    return res;
}

int exist(int key) {
  	printf("PROXY: exist\n");
    init_rpc_client();

    int res;
	//enviamos petición al servidor
	enum clnt_stat stat = exist_1(key, &res, clnt);
	if (stat != RPC_SUCCESS) {
		close_rpc_client();
		return -1;
	}

  	printf("PROXY: devolvemos respuesta\n");
	close_rpc_client();
    return res;
}

int destroy() {
  	printf("PROXY: destroy\n");
    init_rpc_client();

    int res;
	//enviamos petición al servidor
	enum clnt_stat stat = destroy_1(&res, clnt);
	if (stat != RPC_SUCCESS) {
		close_rpc_client();
		return -1;
	}

  	printf("PROXY: devolvemos respuesta\n");
	close_rpc_client();
    return res;
}
